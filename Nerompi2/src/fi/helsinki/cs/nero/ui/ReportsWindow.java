package fi.helsinki.cs.nero.ui;

/**
 * Mahdollistaa tietojen tallentamisen. Näyttää taulukon, jossa olevaa dataa voi
 * järjestää ja rajata haluamallaan tavalla. Taulukossa näytetty data voidaan
 * tallentaa teksti- tai ODS-muodossa. Saa tietonsa Session-luokalta.
 *
 * @author lpesola
 * @see Session
 */
import fi.helsinki.cs.nero.data.Person;
import fi.helsinki.cs.nero.data.Reservation;
import fi.helsinki.cs.nero.data.Room;
import fi.helsinki.cs.nero.db.NeroDatabase;
import fi.helsinki.cs.nero.logic.ODTReportPrinter;
import fi.helsinki.cs.nero.logic.ReportSession;
import fi.helsinki.cs.nero.logic.ReportPrinter;
import fi.helsinki.cs.nero.logic.Session;
import fi.helsinki.cs.nero.logic.TxtReportPrinter;
import java.io.File;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Vector;
import javax.swing.DefaultRowSorter;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JTable;
import javax.swing.RowFilter;
import javax.swing.RowFilter.ComparisonType;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;
import javax.swing.table.TableModel;
import javax.swing.table.TableRowSorter;

public class ReportsWindow extends javax.swing.JFrame {

    private Session session;
    private ReportSession rsession;
    private List<String> initialColumns;
    private List<JCheckBox> initialComponents;
    private List<String> initiallyHiddenColumns;
    private List<JComponent> peopleComponents;
    private List<JComponent> roomComponents;
    private TableColumnModel columnModel;
    private JTable roomTable;
    private JTable peopleTable;
    private HashMap<String, IndexedColumn> hiddenColumns;
    private Person[] people;
    private Room[] rooms;
    private Vector<Vector<Object>> peopleTableData;
    private Vector<Vector<Object>> roomTableData;
    private Vector<String> peopleColumnNames;
    private Vector<String> roomColumnNames;
    private TableColumnModel roomColumnModel;
    private TableColumnModel peopleColumnModel;
    private NeroTableModel peopleModel;
    private TableRowSorter<TableModel> rowSorter;
    private RowFilter generalFilter;
    private Map<String, RowFilter> filterList;
    private ReportPrinter printer;
    private Date today;
    private String varaus, nimi, huone, nimike, sposti;
    private String postihuone, puhelinnumero;
    private String kerros, pisteiden_lkm, siipi, kuvaus, huoneen_koko, pistevaraukset, avainvaraukset;
    private String structuredFileType;
    private List<JCheckBox> defaultRoomCheckboxes;
    private List<String> defaultRoomColumns;

    /**
     * Creates new form Reports
     */
    public ReportsWindow() {

        // koodia testausta varten, voi poistaa kun tämä ikkuna
        // integroidaan muuhun käliin
        // toimiva sessio
        session = new Session();
        NeroDatabase db = new NeroDatabase(session,
                "oracle.jdbc.driver.OracleDriver",
                "jdbc:oracle:thin:@bodbacka:1521:test",
                "tk_testi", "tapaus2");
        session.setDatabase(db);
        // testikoodin loppu
        rsession = new ReportSession();

        today = new Date();
        people = session.getFilteredPeople();
        rooms = session.getRooms();
        filterList = new HashMap<>();
        hiddenColumns = new HashMap<>();

        initStringVariables();
        initComponents();
        initContainers();
        initColumnData();
        // oletusarvoisesti näytetään henkilönäkymä
        switchToPeopleData();
        showColumns(initiallyHiddenColumns);
        this.setVisible(true);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        viewButtons = new javax.swing.ButtonGroup();
        fileChooserDialog = new javax.swing.JFileChooser();
        overwriteCheck = new javax.swing.JOptionPane();
        saveButton = new javax.swing.JButton();
        fileTypeChooser = new javax.swing.JComboBox();
        ColumnsLabel = new javax.swing.JLabel();
        tableContainer = new javax.swing.JScrollPane();
        table = new javax.swing.JTable();
        restrictionsContainer = new javax.swing.JPanel();
        wing = new javax.swing.JLabel();
        restrictByWing = new javax.swing.JComboBox();
        floor = new javax.swing.JLabel();
        floorDropdown = new javax.swing.JComboBox();
        restrictByHasLocker = new javax.swing.JComboBox();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        restrictByName = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        lastCalendar = new net.sourceforge.jcalendarbutton.JCalendarButton();
        firstCalendar = new net.sourceforge.jcalendarbutton.JCalendarButton();
        restrictByFirstDate = new javax.swing.JTextField();
        restrictByLastDate = new javax.swing.JTextField();
        restrictByLockerRoom = new javax.swing.JComboBox();
        jLabel6 = new javax.swing.JLabel();
        showInactive = new javax.swing.JCheckBox();
        postroomLabel = new javax.swing.JLabel();
        roomLabel = new javax.swing.JLabel();
        personLabel = new javax.swing.JLabel();
        columnChekboxes = new javax.swing.JPanel();
        showRoomAndPost = new javax.swing.JCheckBox();
        showPhone = new javax.swing.JCheckBox();
        showJobTitle = new javax.swing.JCheckBox();
        showEmail = new javax.swing.JCheckBox();
        showRoomReservations = new javax.swing.JCheckBox();
        showFloor = new javax.swing.JCheckBox();
        showPostCount = new javax.swing.JCheckBox();
        showLocker = new javax.swing.JCheckBox();
        showWing = new javax.swing.JCheckBox();
        showSize = new javax.swing.JCheckBox();
        showRoomKeyReservations = new javax.swing.JCheckBox();
        showPostReservations = new javax.swing.JCheckBox();
        showDescription = new javax.swing.JCheckBox();
        dataModeSelector = new javax.swing.JComboBox();
        jLabel7 = new javax.swing.JLabel();

        fileChooserDialog.setDialogTitle("Tallenna");

        overwriteCheck.setMessage("Ylikirjoitetaanko?");
        overwriteCheck.setMessageType(JOptionPane.QUESTION_MESSAGE);
        overwriteCheck.setOptionType(JOptionPane.YES_NO_OPTION);

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Raportit");

        saveButton.setText("Tallenna");
        saveButton.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                saveButtonMouseReleased(evt);
            }
        });

        fileTypeChooser.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "txt", "ODS" }));

        ColumnsLabel.setText("Sarakkeet");

        tableContainer.setPreferredSize(new java.awt.Dimension(700, 700));

        table.setAutoCreateColumnsFromModel(false);
        table.setAutoCreateRowSorter(true);
        table.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {},
                {},
                {},
                {}
            },
            new String [] {

            }
        ));
        table.setEnabled(false);
        table.setRowSelectionAllowed(false);
        tableContainer.setViewportView(table);

        wing.setText("Siipi");

        restrictByWing.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "A", "B", "C", "D", "Kaikki" }));
        restrictByWing.setToolTipText("");
        restrictByWing.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                restrictByWingItemStateChanged(evt);
            }
        });

        floor.setText("Kerros");

        floorDropdown.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "1", "2", "3", "Kaikki" }));
        floorDropdown.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                floorDropdownItemStateChanged(evt);
            }
        });

        restrictByHasLocker.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Kaikki", "Lokerottomat", "Lokerolliset" }));
        restrictByHasLocker.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                restrictByHasLockerItemStateChanged(evt);
            }
        });

        jLabel1.setText("Näytä");

        jLabel2.setText("Varaus päättyy aikavälillä");
        jLabel2.setToolTipText("Aseta aikaväli, jonka aikana päättyvät varaukset näytetään");

        jLabel3.setText("Nimi");

        restrictByName.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                restrictByNameActionPerformed(evt);
            }
        });

        jLabel4.setText("Alkupvm.");

        jLabel5.setText("Loppupvm.");

        lastCalendar.setToolTipText("Aikavälin viimeinen päivä");
        lastCalendar.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                lastCalendarPropertyChange(evt);
            }
        });

        firstCalendar.setToolTipText("Aikavälin ensimmäinen päivä");
        firstCalendar.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                firstCalendarPropertyChange(evt);
            }
        });

        restrictByFirstDate.setHorizontalAlignment(javax.swing.JTextField.TRAILING);
        restrictByFirstDate.setText(new SimpleDateFormat("dd.MM.yyyy").format(today));
        restrictByFirstDate.setToolTipText("Aikavälin ensimmäinen päivä muodossa DD.MM.YYYY");
        restrictByFirstDate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                restrictByFirstDateActionPerformed(evt);
            }
        });

        restrictByLastDate.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        restrictByLastDate.setText("31.12.2112");
        restrictByLastDate.setToolTipText("Aikavälin viimeinen päivä muodossa DD.MM.YYYY");
        restrictByLastDate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                restrictByLastDateActionPerformed(evt);
            }
        });

        restrictByLockerRoom.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "2", "3", "Sivutoimiset", "Kaikki" }));
        restrictByLockerRoom.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                restrictByLockerRoomItemStateChanged(evt);
            }
        });

        jLabel6.setText("Huone");

        showInactive.setText("Näytä myös ei-aktiiviset");
        showInactive.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                showInactiveMouseReleased(evt);
            }
        });

        postroomLabel.setText("Postihuone");

        roomLabel.setText("Huone");

        personLabel.setText("Henkilöt");

        javax.swing.GroupLayout restrictionsContainerLayout = new javax.swing.GroupLayout(restrictionsContainer);
        restrictionsContainer.setLayout(restrictionsContainerLayout);
        restrictionsContainerLayout.setHorizontalGroup(
            restrictionsContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(restrictionsContainerLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(restrictionsContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(restrictionsContainerLayout.createSequentialGroup()
                        .addGroup(restrictionsContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(showInactive)
                            .addGroup(restrictionsContainerLayout.createSequentialGroup()
                                .addComponent(jLabel3)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(restrictByName, javax.swing.GroupLayout.PREFERRED_SIZE, 148, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(18, 18, 18))
                    .addComponent(personLabel))
                .addGroup(restrictionsContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(restrictionsContainerLayout.createSequentialGroup()
                        .addGroup(restrictionsContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel5, javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jLabel4, javax.swing.GroupLayout.Alignment.TRAILING))
                        .addGap(18, 18, 18)
                        .addGroup(restrictionsContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(restrictByLastDate)
                            .addComponent(restrictByFirstDate, javax.swing.GroupLayout.DEFAULT_SIZE, 97, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(restrictionsContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(firstCalendar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lastCalendar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(28, 28, 28)
                        .addGroup(restrictionsContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1, javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jLabel6, javax.swing.GroupLayout.Alignment.TRAILING)))
                    .addGroup(restrictionsContainerLayout.createSequentialGroup()
                        .addGap(12, 12, 12)
                        .addComponent(jLabel2)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(restrictionsContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(restrictionsContainerLayout.createSequentialGroup()
                        .addGroup(restrictionsContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(restrictByHasLocker, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(restrictByLockerRoom, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGap(30, 30, 30)
                        .addGroup(restrictionsContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(floor)
                            .addComponent(wing)))
                    .addComponent(postroomLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(restrictionsContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(restrictionsContainerLayout.createSequentialGroup()
                        .addComponent(roomLabel)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(restrictionsContainerLayout.createSequentialGroup()
                        .addGroup(restrictionsContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(restrictByWing, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(floorDropdown, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap(325, Short.MAX_VALUE))))
        );
        restrictionsContainerLayout.setVerticalGroup(
            restrictionsContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(restrictionsContainerLayout.createSequentialGroup()
                .addGap(2, 2, 2)
                .addGroup(restrictionsContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(roomLabel)
                    .addComponent(postroomLabel)
                    .addComponent(jLabel2)
                    .addComponent(personLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(restrictionsContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(restrictByWing, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(wing)
                    .addComponent(restrictByHasLocker, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel1)
                    .addComponent(firstCalendar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(restrictByFirstDate, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel4)
                    .addComponent(restrictByName, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(restrictionsContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(showInactive, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(restrictByLastDate, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lastCalendar, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel5, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel6, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(restrictByLockerRoom, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(floor, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(floorDropdown, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(62, 62, 62))
        );

        showRoomAndPost.setText(huone);
        showRoomAndPost.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                showRoomAndPostMouseReleased(evt);
            }
        });

        showPhone.setText(puhelinnumero);
        showPhone.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                showPhoneMouseReleased(evt);
            }
        });

        showJobTitle.setText(nimike);
        showJobTitle.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                showJobTitleMouseReleased(evt);
            }
        });

        showEmail.setText(sposti);
        showEmail.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                showEmailMouseReleased(evt);
            }
        });

        showRoomReservations.setText(varaus);
        showRoomReservations.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                showRoomReservationsMouseReleased(evt);
            }
        });

        showFloor.setText("Kerros");
        showFloor.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                showFloorMouseReleased(evt);
            }
        });

        showPostCount.setText("Työpisteiden lkm");
        showPostCount.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                showPostCountActionPerformed(evt);
            }
        });

        showLocker.setText("Postilokero");
        showLocker.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                showLockerMouseReleased(evt);
            }
        });

        showWing.setText("Siipi");
        showWing.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                showWingMouseReleased(evt);
            }
        });

        showSize.setText("Koko");
        showSize.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                showSizeMouseReleased(evt);
            }
        });

        showRoomKeyReservations.setText("Avainvaraukset");
        showRoomKeyReservations.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                showRoomKeyReservationsMouseReleased(evt);
            }
        });

        showPostReservations.setText("Työpistevaraukset");
        showPostReservations.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                showPostReservationsMouseReleased(evt);
            }
        });

        showDescription.setText("Kuvaus");
        showDescription.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                showDescriptionMouseReleased(evt);
            }
        });

        javax.swing.GroupLayout columnChekboxesLayout = new javax.swing.GroupLayout(columnChekboxes);
        columnChekboxes.setLayout(columnChekboxesLayout);
        columnChekboxesLayout.setHorizontalGroup(
            columnChekboxesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(columnChekboxesLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(columnChekboxesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(showSize)
                    .addComponent(showRoomKeyReservations)
                    .addComponent(showPostReservations)
                    .addComponent(showDescription))
                .addContainerGap(64, Short.MAX_VALUE))
            .addGroup(columnChekboxesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(columnChekboxesLayout.createSequentialGroup()
                    .addContainerGap()
                    .addGroup(columnChekboxesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addComponent(showWing)
                        .addComponent(showRoomAndPost)
                        .addComponent(showPostCount)
                        .addComponent(showFloor)
                        .addComponent(showRoomReservations)
                        .addComponent(showEmail)
                        .addComponent(showJobTitle)
                        .addComponent(showPhone)
                        .addComponent(showLocker))
                    .addContainerGap(23, Short.MAX_VALUE)))
        );
        columnChekboxesLayout.setVerticalGroup(
            columnChekboxesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(columnChekboxesLayout.createSequentialGroup()
                .addGap(224, 224, 224)
                .addComponent(showSize)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(showRoomKeyReservations)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(showPostReservations)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(showDescription)
                .addContainerGap(261, Short.MAX_VALUE))
            .addGroup(columnChekboxesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(columnChekboxesLayout.createSequentialGroup()
                    .addContainerGap()
                    .addComponent(showRoomAndPost)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(showPhone)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(showJobTitle)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(showEmail)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(showRoomReservations)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(showFloor)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(showPostCount)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(showLocker)
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(showWing)
                    .addContainerGap(362, Short.MAX_VALUE)))
        );

        dataModeSelector.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Henkilöt", "Huoneet" }));
        dataModeSelector.setToolTipText("Näytetäänkö tiedot huoneiden vai henkilöiden mukaan");
        dataModeSelector.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                dataModeSelectorItemStateChanged(evt);
            }
        });

        jLabel7.setText("Näytä kaikki");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(restrictionsContainer, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(ColumnsLabel)
                            .addComponent(dataModeSelector, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel7)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(6, 6, 6)
                                .addComponent(columnChekboxes, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(20, 20, 20)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(saveButton)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(fileTypeChooser, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(tableContainer, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 993, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(restrictionsContainer, javax.swing.GroupLayout.PREFERRED_SIZE, 111, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(9, 9, 9)
                        .addComponent(jLabel7)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(dataModeSelector, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(ColumnsLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(columnChekboxes, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(12, 12, 12)
                        .addComponent(tableContainer, javax.swing.GroupLayout.PREFERRED_SIZE, 670, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(fileTypeChooser, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(saveButton, javax.swing.GroupLayout.Alignment.TRAILING))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void showPostCountActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_showPostCountActionPerformed
        setColumnVisibility(showPostCount, pisteiden_lkm);
    }//GEN-LAST:event_showPostCountActionPerformed

    private void showRoomReservationsMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_showRoomReservationsMouseReleased
        setColumnVisibility(showRoomReservations, varaus);
    }//GEN-LAST:event_showRoomReservationsMouseReleased

    private void showFloorMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_showFloorMouseReleased
        setColumnVisibility(showFloor, kerros);
    }//GEN-LAST:event_showFloorMouseReleased

    private void showRoomAndPostMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_showRoomAndPostMouseReleased
        setColumnVisibility(showRoomAndPost, huone);
    }//GEN-LAST:event_showRoomAndPostMouseReleased

    /**
     * Tapahtumakäsittelijä, joka pyytää tallentamaan taulukossa tällä hetkellä
     * näkyvissä olevan datan. Tarkistetaan, mikä tiedosto on määritelty
     * tallennuksen kohteeksi. Jos se on jokin olemassaoleva, tarkistetaan,
     * voiko sen päälle tallentaa.
     *
     * @param evt
     * @see promptForOverWrite()
     */
    private void saveButtonMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_saveButtonMouseReleased

        int option = fileChooserDialog.showSaveDialog(table);
        // tallennus vain, jos on painettu "OK/Tallenna"
        if (option == JFileChooser.APPROVE_OPTION) {
            File f = fileChooserDialog.getSelectedFile();
            // kirjoitetaan vain jos tiedosto on uusi tai jos vanhan päälle saa kirjoittaa
            boolean writable = (!f.exists() || promptForOverWrite());
            if (writable) {
                print(f);
            }
        }
    }//GEN-LAST:event_saveButtonMouseReleased

    private void showJobTitleMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_showJobTitleMouseReleased
        setColumnVisibility(showJobTitle, nimike);
    }//GEN-LAST:event_showJobTitleMouseReleased

    private void showEmailMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_showEmailMouseReleased
        setColumnVisibility(showEmail, sposti);
    }//GEN-LAST:event_showEmailMouseReleased

    private void showWingMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_showWingMouseReleased
        setColumnVisibility(showWing, siipi);
    }//GEN-LAST:event_showWingMouseReleased

    private void showPhoneMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_showPhoneMouseReleased
        setColumnVisibility(showPhone, puhelinnumero);
    }//GEN-LAST:event_showPhoneMouseReleased

    private void showLockerMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_showLockerMouseReleased
        setColumnVisibility(showLocker, postihuone);
    }//GEN-LAST:event_showLockerMouseReleased

    private void showInactiveMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_showInactiveMouseReleased
        if (showInactive.isSelected()) {
            session.setFilterActiveEmployees(false);
            people = session.getFilteredPeople();
            showInactive();
        } else {
            session.setFilterActiveEmployees(true);
            people = session.getFilteredPeople();
            showInactive();
        }
    }//GEN-LAST:event_showInactiveMouseReleased

    private void restrictByLockerRoomItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_restrictByLockerRoomItemStateChanged
        String room = restrictByLockerRoom.getSelectedItem().toString();
        if (room.isEmpty() || room.equalsIgnoreCase("kaikki")) {
            removeFilter(postihuone);
        } else {
            addRegexpFilter(room, postihuone);
        }
    }//GEN-LAST:event_restrictByLockerRoomItemStateChanged

    private void restrictByLastDateActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_restrictByLastDateActionPerformed
        determineDateRestriction();
    }//GEN-LAST:event_restrictByLastDateActionPerformed

    private void restrictByFirstDateActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_restrictByFirstDateActionPerformed
        determineDateRestriction();
    }//GEN-LAST:event_restrictByFirstDateActionPerformed

    private void firstCalendarPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_firstCalendarPropertyChange
        if (evt.getNewValue() instanceof Date) {
            String strDate = new SimpleDateFormat("dd.MM.yyyy").format(evt.getNewValue());
            restrictByFirstDate.setText(strDate);
            determineDateRestriction();
        }
    }//GEN-LAST:event_firstCalendarPropertyChange

    private void lastCalendarPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_lastCalendarPropertyChange
        if (evt.getNewValue() instanceof Date) {
            String strDate = new SimpleDateFormat("dd.MM.yyyy").format(evt.getNewValue());            
            restrictByLastDate.setText(strDate);
            determineDateRestriction();
        }
    }//GEN-LAST:event_lastCalendarPropertyChange

    private void restrictByNameActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_restrictByNameActionPerformed
        String value = restrictByName.getText();
        if (value == null || value.isEmpty()) {
            removeFilter(nimi);
        } else {
            addRegexpFilter(value, nimi);
        }
    }//GEN-LAST:event_restrictByNameActionPerformed

    private void restrictByHasLockerItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_restrictByHasLockerItemStateChanged
        int index = restrictByHasLocker.getSelectedIndex();
        String value;
        if (index == 0) {
            // kaikki
            removeFilter(postihuone);
        } else if (index == 1) {
            // lokerottomat
            value = "ei postilokeroa";
            addRegexpFilter(value, postihuone);
        } else if (index == 2) {
            // lokerolliset
            RowFilter regexFilter = RowFilter.regexFilter("ei postilokeroa",
                    convertColumnIndexToModel(columnModel.getColumnIndex(postihuone)));
            RowFilter filter = RowFilter.notFilter(regexFilter);
            addFilter(postihuone, filter);
        }
    }//GEN-LAST:event_restrictByHasLockerItemStateChanged

    private void floorDropdownItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_floorDropdownItemStateChanged
        String value = floorDropdown.getSelectedItem().toString();
        if (value.equals("Kaikki")) {
            removeFilter(kerros);
        } else {
            addRegexpFilter(value, kerros);
        }
    }//GEN-LAST:event_floorDropdownItemStateChanged

    private void restrictByWingItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_restrictByWingItemStateChanged
        String value = restrictByWing.getSelectedItem().toString();
        if (value.equals("Kaikki")) {
            removeFilter(siipi);
        } else {
            addRegexpFilter(value, siipi);
        }
    }//GEN-LAST:event_restrictByWingItemStateChanged

    private void dataModeSelectorItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_dataModeSelectorItemStateChanged
        String value = dataModeSelector.getSelectedItem().toString();
        switch (value) {
            case "Huoneet":
                switchToRoomData();
                break;
            case "Henkilöt":
                switchToPeopleData();
                break;
        }
    }//GEN-LAST:event_dataModeSelectorItemStateChanged

    private void showSizeMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_showSizeMouseReleased
        setColumnVisibility(showSize, huoneen_koko);
    }//GEN-LAST:event_showSizeMouseReleased

    private void showRoomKeyReservationsMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_showRoomKeyReservationsMouseReleased
        setColumnVisibility(showRoomKeyReservations, avainvaraukset);
    }//GEN-LAST:event_showRoomKeyReservationsMouseReleased

    private void showPostReservationsMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_showPostReservationsMouseReleased
        setColumnVisibility(showPostReservations, pistevaraukset);
    }//GEN-LAST:event_showPostReservationsMouseReleased

    private void showDescriptionMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_showDescriptionMouseReleased
        setColumnVisibility(showDescription, kuvaus);
    }//GEN-LAST:event_showDescriptionMouseReleased
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ReportsWindow.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ReportsWindow.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ReportsWindow.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ReportsWindow.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new ReportsWindow().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel ColumnsLabel;
    private javax.swing.JPanel columnChekboxes;
    private javax.swing.JComboBox dataModeSelector;
    private javax.swing.JFileChooser fileChooserDialog;
    private javax.swing.JComboBox fileTypeChooser;
    private net.sourceforge.jcalendarbutton.JCalendarButton firstCalendar;
    private javax.swing.JLabel floor;
    private javax.swing.JComboBox floorDropdown;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private net.sourceforge.jcalendarbutton.JCalendarButton lastCalendar;
    private javax.swing.JOptionPane overwriteCheck;
    private javax.swing.JLabel personLabel;
    private javax.swing.JLabel postroomLabel;
    private javax.swing.JTextField restrictByFirstDate;
    private javax.swing.JComboBox restrictByHasLocker;
    private javax.swing.JTextField restrictByLastDate;
    private javax.swing.JComboBox restrictByLockerRoom;
    private javax.swing.JTextField restrictByName;
    private javax.swing.JComboBox restrictByWing;
    private javax.swing.JPanel restrictionsContainer;
    private javax.swing.JLabel roomLabel;
    private javax.swing.JButton saveButton;
    private javax.swing.JCheckBox showDescription;
    private javax.swing.JCheckBox showEmail;
    private javax.swing.JCheckBox showFloor;
    private javax.swing.JCheckBox showInactive;
    private javax.swing.JCheckBox showJobTitle;
    private javax.swing.JCheckBox showLocker;
    private javax.swing.JCheckBox showPhone;
    private javax.swing.JCheckBox showPostCount;
    private javax.swing.JCheckBox showPostReservations;
    private javax.swing.JCheckBox showRoomAndPost;
    private javax.swing.JCheckBox showRoomKeyReservations;
    private javax.swing.JCheckBox showRoomReservations;
    private javax.swing.JCheckBox showSize;
    private javax.swing.JCheckBox showWing;
    private javax.swing.JTable table;
    private javax.swing.JScrollPane tableContainer;
    private javax.swing.ButtonGroup viewButtons;
    private javax.swing.JLabel wing;
    // End of variables declaration//GEN-END:variables

    /**
     * Ryhmitetään checkboxit ja alasvetovalikot niiden käyttötarkoituksen
     * mukaan. Tämä on niiden käsittelyn helpottamista varten.
     */
    private void initContainers() {

        /* sarakkeet, jotka näytetään oletusarvoisesti */
        initialColumns = new ArrayList<>();
        initialColumns.add(nimi);
        initialColumns.add(nimike);
        initialColumns.add(huone);
        initialColumns.add(varaus);

        /* ne checkboxit, jotka ovat valittuna oletusarvoisesti */
        initialComponents = new ArrayList<>();
        initialComponents.add(showRoomAndPost);
        initialComponents.add(showRoomReservations);
        initialComponents.add(showJobTitle);

        defaultRoomCheckboxes = new ArrayList<>();
        defaultRoomCheckboxes.add(showFloor);
        defaultRoomCheckboxes.add(showWing);
        defaultRoomCheckboxes.add(showPostCount);
        defaultRoomCheckboxes.add(showDescription);

        /* ne sarakkeet, jotka ovat aluksi piilossa */
        initiallyHiddenColumns = new ArrayList<>();
        initiallyHiddenColumns.add(kerros);
        initiallyHiddenColumns.add(siipi);
        initiallyHiddenColumns.add(pisteiden_lkm);
        initiallyHiddenColumns.add(sposti);
        initiallyHiddenColumns.add(puhelinnumero);
        initiallyHiddenColumns.add(postihuone);

        defaultRoomColumns = new ArrayList<>();
        defaultRoomColumns.add(huoneen_koko);
        defaultRoomColumns.add(avainvaraukset);
        defaultRoomColumns.add(pistevaraukset);

        /*Pelkästään huoneisiin liittyvät rajoittimet*/
        roomComponents = new ArrayList<>();
        roomComponents.add(showSize);
        roomComponents.add(showRoomKeyReservations);
        roomComponents.add(showPostReservations);
        roomComponents.add(showDescription);

        /*Pelkästään henkilöihin liittyvät rajoittimet*/
        peopleComponents = new ArrayList<>();
        peopleComponents.add(restrictByLockerRoom);
        peopleComponents.add(restrictByFirstDate);
        peopleComponents.add(restrictByLastDate);
        peopleComponents.add(restrictByHasLocker);
        peopleComponents.add(showPhone);
        peopleComponents.add(showJobTitle);
        peopleComponents.add(showEmail);
        peopleComponents.add(showRoomReservations);
        peopleComponents.add(showLocker);
        peopleComponents.add(showRoomReservations);
        peopleComponents.add(firstCalendar);
        peopleComponents.add(lastCalendar);
        peopleComponents.add(showInactive);
        peopleComponents.add(showRoomAndPost);

    }


    /**
     * Alustaa GUI taulukossa tarvittavat tiedot ja luo näistä kaksi
     * taulukkoa, joiden välillä raporttinäkymässä voidaan vaihtaa: 
     * henkilö- sekä huonetaulukon.
     * Alustaa näiden sarakkeiden nimet 
     * sekä sarakkeiden datan ja näitä vastaavat mallit.
     * Data saadaan Sessiolta. Huonedataa ei koskaan
     * muuteta - se pysyy samana sen jälkeen, kun se on kerran haettu.
     * Henkilödata saatetaan hakea uudestaan, jos käyttäjä haluaa mukaan myös
     * epäaktiiviset henkilöt.
     * Joka tapauksessa idea on se, että taulukkomalli ei koskaan muutu - vain
     * näkymää muutetaan.
     * Taulukkoja on kaksi: henkilöiden ja huoneiden perusteella listatut.
     * Datan alustamisen lisäksi luodaan tarvittavat malit henkilödataa varten.
     * @See NeroTableModel
     */
    private void initColumnData() {

        initColumnNames();
        
        initRoomData();
        roomTable = new JTable(roomTableData, roomColumnNames);

        initPeopleData();
        // henkilödata käyttää DefaultTableModelin aliluokkaa NeroTableModelia
        // joka tarvitsee toimiakseen tietoonsa sen, mihin taulukkoon
        // se liittyy sekä taulukon sarakemallin
        // luodaan nämä ja liitetään ne malliin
        peopleModel = new NeroTableModel(varaus);
        peopleModel.setDataVector(peopleTableData, peopleColumnNames);
        peopleTable = new JTable(peopleModel);
        peopleColumnModel = peopleTable.getColumnModel();
        peopleModel.setColumnModel(peopleColumnModel);
        peopleTable.setAutoCreateColumnsFromModel(false);
        peopleModel.setTable(table);
        // asetetaan varaus-sarakkeelle oma renderer päivämäärää varten
        // jotta se voidaan esittää lyhyessä muodossa
        TableCellRenderer renderer = new DateCellRenderer();
        peopleColumnModel.getColumn(peopleColumnModel.getColumnIndex(varaus)).setCellRenderer(renderer);
    }

    /**
     * Asetetaan sarakkeille nimet.
     */
    private void initColumnNames() {

        peopleColumnNames = new Vector<>();
        peopleColumnNames.add(nimi);
        peopleColumnNames.add(nimike);
        peopleColumnNames.add(huone);
        peopleColumnNames.add(kerros);
        peopleColumnNames.add(siipi);
        peopleColumnNames.add(pisteiden_lkm);
        peopleColumnNames.add(varaus);
        peopleColumnNames.add(sposti);
        peopleColumnNames.add(puhelinnumero);
        peopleColumnNames.add(postihuone);

        roomColumnNames = new Vector<>();
        roomColumnNames.add(nimi);
        roomColumnNames.add(kerros);
        roomColumnNames.add(siipi);
        roomColumnNames.add(pisteiden_lkm);
        roomColumnNames.add(huoneen_koko);
        roomColumnNames.add(kuvaus);
        roomColumnNames.add(avainvaraukset);
        roomColumnNames.add(pistevaraukset);

    }

    /**
     * Näyttää aiemmin piilotetun sarakkeen. Hakee piilotetut sarakkeet
     * sisältävästä kartasta oikean sarakkeen ja lisää sen sarakemalliin. Jos
     * sarake ei ollut laitimmainen, siirretään sitä tarvittava määrä
     * vasemmalle.
     *
     * @param name sarakkeen identifier / sen otsake
     * @param model taulukkomalli, johon sarake lisätään
     * @param hiddenColumns map, josta piilotettu sarake haetaan
     * @see IndexedColumn
     */
    private void showColumn(String name) {

        IndexedColumn column = hiddenColumns.remove(name);
        if (column != null) {
            columnModel.addColumn(column.getTableColumn());
            int lastColumn = columnModel.getColumnCount() - 1;
            if (column.getIndex() < lastColumn) {
                columnModel.moveColumn(lastColumn, column.getIndex());
            }
        }
    }

    /**
     * Piilottaa tällä hetkellä näkyvillä olevan sarakkeen. Hakee sarakkeen
     * saamansa nimen perusteella ja luo sen pohjalta uuden ilmentymän
     * IndexedColumn-luokasta. Tälle ilmentymälle annetaan sama indeksi kuin
     * mikä piilotettavalla sarakkeella on. IndexedColumn säilötään mapiin,
     * josta se voidaan tarvittaessa hakea taas takaisin näytettäväksi. Tämän
     * jälkeen poistetaan sarake taulukkomallista.
     *
     * @param name sarakkeen identifier / sen otsake
     * @param model sarakemalli, josta sarake poistetaan
     * @param hiddenColumns map, johon piilotettava sarake laitetaan talteen
     * @see IndexedColumn
     */
    private void hideColumn(String name) {

        try {
            int index = columnModel.getColumnIndex(name);
            TableColumn column = columnModel.getColumn(index);
            IndexedColumn indexedColumn = new IndexedColumn(index, column);
            hiddenColumns.put(name, indexedColumn);
            columnModel.removeColumn(column);
        } catch (IllegalArgumentException ex) {
            System.out.println("Sarake " + name + " ei ollut näkyvissä. Ei voida piilottaa."
                    + "\nMetodi: hideColumn");
        }
    }

    /**
     * Asettaa kaikkien saamiensa checboxien tilaksi selected.
     *
     * @param components, lista komponenteista, joiden tila muutetaan
     */
    private void setSelected(List<JCheckBox> components) {
        for (JCheckBox jcomp : components) {
            jcomp.setSelected(true);
        }
    }

    /**
     * Lisää GUIn taulukolle sorterin, joka mahdollistaa datan järjestämisen
     * sarakkeittain.
     */
    private void addSorter() {
        rowSorter = new TableRowSorter<>(table.getModel());
        table.setRowSorter(rowSorter);
    }

    /**
     * Käy läpi näkyvillä olevat sarakkeet ja palauttaa niiden indeksit. Pyytää
     * taulukolta sen sarakemallin ja pyytää siltä sarakkeet (nämä ovat siis
     * näkyvillä). Iteroi niiden läpi ja tarkistaa, mikä niiden indeksi on.
     * Lisää indeksin taulukkoon.
     *
     * @return taulukko tällä hetkellä näkyvillä olevien sarakkeiden indekseistä
     */
    private int[] listShownColumnsByIndex() {
        Enumeration<TableColumn> e = table.getColumnModel().getColumns();
        int[] neededIndexes = new int[table.getColumnCount()];
        int z = 0;
        while (e.hasMoreElements()) {
            String s = e.nextElement().getIdentifier().toString();
            neededIndexes[z] = table.getColumnModel().getColumnIndex(s);
            z++;
        }
        return neededIndexes;
    }

    /**
     * Hakee GUIn taulukossa tällä hetkellä näkyvillä olevan datan. Luo listan,
     * jonka alkiot vastaavat taulukon rivejä. Alkiot ovat listoja, joiden
     * alkiot vastaavat rivin sarakkeita. Hakee näkyvillä olevat sarakkeiden
     * nimet ja tämän jälkeen näkyvillä olevan datan ja yhdistää nämä yhdeksi
     * listaksi.
     *
     * @return lista listoja, joka kuvaa GUIn taulukossa tällä hetkellä
     * näkyvillä olevan datan
     * @see getShownColumnIdentifiers()
     * @see getShownColumnData()
     */
    private List<List> getTableDataAsList() {

        List<List> list = new ArrayList<>();
        /* - tarkista, mitkä sarakkeet ovat näkyvillä
         * - ota talteen niiden nimet ja laita ensimmäiseksi listaan
         * - hae data niistä sarakkeista, jotka ovat näkyvillä
         */
        List columnIdentifiers = getShownColumnIdentifiers();
        list.add(0, columnIdentifiers);
        list.addAll(1, getShownColumnData());

        return list;
    }

    /**
     * Tuottaa Date-oliosta merkkijonon, joka kuvaa sen päivämäärän.
     *
     * @param date päivämäärä, josta teksti muodostetaan
     * @return annettu päivämäärä merkkijonona, joka on muotoa pp.kk.vvvv
     */
    private String dateToShortString(Date date) {
        if (date != null) {
            String dateString = "";
            dateString = dateString.concat(date.getDate() + ".");
            dateString = dateString.concat((1 + date.getMonth()) + ".");
            dateString = dateString.concat(new Integer((date.getYear()) + 1900).toString());
            return dateString;
        } else {
            return null;
        }
    }

    /**
     * Tarkistaa, minkälaisia päivämääräpohjaisia rajoitteita GUIssa on
     * määriteltynä tällä hetkellä ja rajaa taulukon dataa sen mukaan.
     *
     * Jos molemmissa päivämääräkentissä on jokin päivämäärä, näytetään vain ne
     * rivit, joiden varauskentän päivämäärä sijoittuu näiden kahden päivämäärän
     * välille. Jos vain loppupäivämääräkentässä on päivämäärä, näytetään vain
     * ne rivit, joiden varauskentän päivämäärä on ennen asetettua päivämäärää
     * Jos vain alkupäivämääräkentässä on päivämäärä, näytetään vain ne rivit,
     * joiden varauskentän päivämäärä on asetetun päivämäärän jälkeen. Jos
     * kummassakaan ei ole mitään, poistetaan päivämäärärajoitin kokonaan ja
     * näytetään kaikki rivit.
     */
    private void determineDateRestriction() {
        Date firstDate = hasDate(restrictByFirstDate.getText());
        Date lastDate = hasDate(restrictByLastDate.getText());
        RowFilter filter;
        try {
            if (firstDate != null && lastDate != null) {
                // molemmissa päivämäärä
                filter = getDateFilter(firstDate, lastDate);
                addFilter(varaus, filter);
            } else if (firstDate == null && lastDate != null) {
                // loppupäivämäärä on määritelty
                filter = getDateFilter(lastDate, RowFilter.ComparisonType.BEFORE);
                addFilter(varaus, filter);
            } else if (firstDate != null && lastDate == null) {
                // alkupäivämäärä on määritelty
                filter = getDateFilter(firstDate, RowFilter.ComparisonType.AFTER);
                addFilter(varaus, filter);
            } else {
                // kumpaakaan ei asetettu
                removeFilter(varaus);
            }
        } catch (IllegalArgumentException ex) {
            System.out.println("Sarake varaus on piilotettu, ei filteröidä. \n"
                    + "Metodi: determineDateRestriction \n" + ex);
        }
    }

    /**
     * Luo Date-oliopohjaisen filterin, jota voidaan käyttää GUIn taulukossa
     * olevan datan rajaamiseen.
     *
     * @param date päivämäärä, johon verrataan
     * @param type Vertailun tyyppi eli hyväksytäänkö ne rivit joissa päivämäärä
     * on ennen vai jälkeen parametrina saadun päivämäärän
     * @return filteri, joka filteröi saamansa päivämäärän ja ehdon mukaan
     */
    private RowFilter getDateFilter(Date date, ComparisonType type) {
        try {
            int index = table.convertColumnIndexToModel(table.getColumnModel().getColumnIndex(varaus));
            RowFilter newFilter = RowFilter.dateFilter(type,
                    date, index);
            return newFilter;
        } catch (IllegalArgumentException ex) {
            throw ex;
        }
    }

    /**
     * Luo filterin, joka testaa useampaa ehtoa ja jota voidaan käyttää GUIn
     * taulukossa olevan datan rajaamiseen. Luodaan kaksi Date-pohjaista
     * filteriä. Vain molempien ehdot täyttävät rivit taulukossa näytetään.
     *
     * @param first alkupäivämäärä
     * @param last loppupäivämäärä
     * @return filteri, joka hyväksyy vain arvot, jotka sijoittuvat parametreina
     * saatujen päivämäärien välille
     * @see getDateFilter(first, last)
     */
    private RowFilter getDateFilter(Date first, Date last) {
        try {
            List<RowFilter<Object, Object>> filters = new ArrayList<>(2);
            filters.add(getDateFilter(last, RowFilter.ComparisonType.BEFORE));
            filters.add(getDateFilter(first, RowFilter.ComparisonType.AFTER));
            RowFilter<Object, Object> newFilter = RowFilter.andFilter(filters);
            return newFilter;
        } catch (IllegalArgumentException ex) {
            throw ex;
        }
    }

    /**
     * Lukee merkkijonon muotoa pp.kk.vvvv ja muodostaa siitä Date-olion
     *
     * @return jos merkkijono on tyhjä tai syöte on null, palautetaa null,
     * muuten palautetaan Date-olio, joka vastaa merkkijonon kuvaamaa
     * päivämäärää
     */
    private Date hasDate(String s) {
        /* Palauttaa muotoa pp.kk.vvvv olevasta merkkijonosta muodostetun päivämäärän
         Jos merkkijono on tyhjä tai syöte on null, palautetaan null*/
        if (s == null | s.isEmpty()) {
            return null;
        } else {
            return parseDate(s);
        }
    }

    /**
     * Määritellään koko luokassa käytössä olevien merkkijonomuuttujien arvot.
     */
    private void initStringVariables() {
        // henkilö
        varaus = "Varaus päättyy";
        nimi = "Nimi";
        huone = "Huone";
        nimike = "Nimike";
        sposti = "Sähköposti";

        // huone
        kerros = "Kerros";
        pisteiden_lkm = "Työpisteiden lkm";
        siipi = "Siipi";
        huoneen_koko = "Huoneen koko";
        kuvaus = "Kuvaus";
        avainvaraukset = "Avainvaraukset";
        pistevaraukset = "Työpistevaraukset";

        // postilokero    
        postihuone = "Postihuone";
        puhelinnumero = "Puhelinnumero";
        structuredFileType = "ODS";
    }

    /**
     * Muodostaa Date-olion merkkijonon kuvaamasta päivämäärästä.
     *
     * @param text, merkkijono, josta päivämäärä luodaan
     * @return Date-luokan ilmentymä, joka sisältää päivämäärän, jonka 'text'
     * kuvaa
     */
    private Date parseDate(String text) {
        Date date = new Date();
        if (text != null) {
            String[] split = text.split("\\.");
            date.setDate(new Integer(split[0]));
            date.setMonth(new Integer(split[1]) - 1);
            date.setYear(new Integer(split[2]) - 1900);
        }
        return date;
    }

    /**
     * Antaa käskyn tulostaa näkyvillä olevan taulukon datan valitussa
     * formaatissa. Tarkistaa, mikä tiedostomuoto on valittu ja valitsee
     * tulostamiseen käytetyn luokan sen mukaan. Antaa kirjoittajalle taulukon
     * näyttämän datan listana.
     *
     * @param f, tiedosto, johon data kirjoitetaan
     */
    private void print(File f) {

        String fileType = fileTypeChooser.getSelectedItem().toString();
        if (fileType.equals(structuredFileType)) {
            printer = new ODTReportPrinter(f);
        } else {
            printer = new TxtReportPrinter(f);
        }
        printer.print(getTableDataAsList());
    }

    /**
     * Selvitetään, saako olemassaolevan tiedoston yli kirjoittaa. Näytetään
     * käyttäjälle pop-up-ikkuna tätä varten. Jos käyttäjä painaa OK,
     * hyväksytään ylikirjoitus. Jos käyttäjä tekee mitä tahansa muuta (esim.
     * sulkee ikkunan) ei hyväksytä ylikirjoitusta.
     *
     * @return true jos tiedostonylikirjoittaminen on ok ja false jos ei ole
     */
    private boolean promptForOverWrite() {

        int option = JOptionPane.showConfirmDialog(fileChooserDialog,
                "Ylikirjoita?", "Tiedosto on jo olemassa",
                JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);
        if (option == JOptionPane.OK_OPTION) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Listaa kaikkien GUIn taulukossa näkyvillä olevien sarakkeiden otsakkeet.
     * Pyytää mallilta kaikki sarakkeet ja käy läpi niiden otsaketiedot.
     *
     * @return lista näkyvillä olevien sarakkeiden otsikoista
     */
    private List getShownColumnIdentifiers() {

        Enumeration<TableColumn> e = table.getColumnModel().getColumns();
        int z = 0;
        List identifiers = new ArrayList();
        while (e.hasMoreElements()) {
            String s = e.nextElement().getIdentifier().toString();
            identifiers.add(z, s);
            z++;
        }
        return identifiers;
    }

    /**
     * Tuottaa kokoelman, joka sisältää kaiken GUIn taulukossa näkyvillä olevan
     * datan. Käy läpi kaikki näkyvät rivit (view) ja selvittää niiden indeksin
     * alla olevassa taulukkomallissa (model). Selvittää jokaisen näkyvillä
     * olevan rivin sarakkeen indeksin mallissa (view -> model) ja hakee rivin
     * ja sarakkeen perusteella taulukosta näkyvän datan.
     *
     * @return kokoelma listoja. Kokoelma sisältää kaiken näkyvillä olevan datan
     * ja se on samassa järjestyksessä kuin se on taulukon näkymässä. Listan
     * alkiot vastaavat rivin sarakkeita ja kokoelman alkiot taulukon rivejä.
     */
    private Collection<? extends List> getShownColumnData() {

        int[] neededIndexes = listShownColumnsByIndex();
        TableModel tableModel = table.getModel();
        DefaultRowSorter rs = (DefaultRowSorter) table.getRowSorter();
        int columnCount = table.getColumnCount();
        int rowCount = rs.getViewRowCount();
        ArrayList list = new ArrayList(rowCount);


        //TODO: ehkä tuon päivämäärän lyhentämisen voi tehdä myöskin jossain muualla
        for (int i = 0; i < rowCount; i++) {
            List rowList = new ArrayList(columnCount);
            int rowIndexInView = rs.convertRowIndexToModel(i);
            for (int j = 0; j < columnCount; j++) {
                Object o = tableModel.getValueAt(rowIndexInView,
                        table.convertColumnIndexToModel(neededIndexes[j]));
                String value;
                if (o == null) {
                    value = "";
                } else if (o.getClass() == Date.class) {
                    value = dateToShortString((Date) o);
                } else {
                    value = o.toString();
                }
                rowList.add(j, value);
            }
            list.add(rowList);
        }
        return list;
    }


    /**
     * Asettaa kaikki saamansa sarakkeet näkyviksi. 
     * 
     * @param col kokoelma sarakkeita 
     */
    private void showColumns(Collection<String> col) {
        for (String identifier : col) {
            try {
                hideColumn(identifier);
            } catch (Exception ex) {
                System.out.println("Metodi: showColumns \n"
                        + ex + " " + identifier);
            }
        }
    }

    /**
     * Piilottaa tai näyttää sarakkeen sen mukaan, onko siihen liittyvä
     * checkbox valittuna vai ei.
     * 
     * @param box checkbox, joka sarakkeeseen liittyy
     * @param columnName sarakkeen nimi
     */
    private void setColumnVisibility(JCheckBox box, String columnName) {
        if (box.isSelected()) {
            showColumn(columnName);
        } else {
            hideColumn(columnName);
        }
    }

    private int convertColumnIndexToModel(int i) {
        return table.convertColumnIndexToModel(i);
    }

    /**
     * Luo regexp-filtterin saamiensa parametrien perusteella.
     * 
     * @param regex säännöllinen lauseke, jonka perusteella filteröidään
     * @param columnName sarake, jonka dataan rajaus kohdistuu
     * @return regexp-filtteri, joka vaikuttaa annettuun sarakkeeseen ja rajaa
     * saadun säännöllisen lausekkeen perusteella
     * @throws IllegalArgumentException jos sarake, jonka perusteella rajataan,
     * ei ole näkyvillä
     */
    private RowFilter getRegexFilter(String regex, String columnName) {
        try {
            RowFilter filter = RowFilter.regexFilter(regex,
                    convertColumnIndexToModel(columnModel.getColumnIndex(columnName)));
            return filter;
        } catch (IllegalArgumentException ex) {
            throw ex;
        }
    }

    /**
     * Poistaa käytöstä valitun filterin.
     * 
     * @param filterColumnName sarake, johon filtteri liittyi 
     */
    private void removeFilter(String filterColumnName) {
        filterList.remove(filterColumnName);
        updateFilterList(new ArrayList(filterList.values()));
    }

    /**
     * Lisää käyttöön filterin.
     * Saa parametrina filterin, jonka lisää käytössä olevien filtereiden listaan
     * ja päivittää sen jälkeen yleisfilterin, joka sisältää kaikki käytössä olevat
     * filterit.
     * @param filterColumnName sarake, johon filterin pitää vaikuttaa
     * @param filter filtteri, joka otetaan käyttöön
     * @see updateFilterList
     */
    private void addFilter(String filterColumnName, RowFilter filter) {
        filterList.put(filterColumnName, filter);
        updateFilterList(new ArrayList(filterList.values()));
    }

    /**
     * Luo ja lisää käyttöön regexp-filterin.
     * 
     * @see addFilter
     * @param filterText teksti, jonka pohjalta regexp-filter luodaan
     * @param columnName sarake, johon filterin pitää vaikuttaa
     */
    private void addRegexpFilter(String filterText, String columnName) {
        try {
            addFilter(columnName, getRegexFilter(filterText, columnName));
        } catch (IllegalArgumentException ex) {
            JOptionPane.showMessageDialog(rootPane,
                    "Rajoituksia voi tehdä vain näkyvillä oleviin sarakkeisiin.",
                    "Sarake ei näkyvillä", JOptionPane.ERROR_MESSAGE);
            System.out.println(ex + " " + columnName);
        }
    }

    /**
     * Luo filterin, joka rajaa taulukon datan sen mukaan, mitä kaikkia 
     * filttereitä on asetettu. 
     * Saa parametrina listan tällä hetkellä käytössä olevista filtereistä ja 
     * luo tämän yleisfilterin niiden perusteella.
     * 
     * @param filters lista niistä filtereistä, jotka ovat käytössä
     */
    private void updateFilterList(List<RowFilter<Object, Object>> filters) {
        try {
            generalFilter = RowFilter.andFilter(filters);
            DefaultRowSorter sorter = (TableRowSorter) table.getRowSorter();
            sorter.setRowFilter(generalFilter);
        } catch (IllegalArgumentException ex) {
            JOptionPane.showMessageDialog(rootPane,
                    "Rajoituksia voi tehdä vain näkyvillä oleviin sarakkeisiin",
                    "Sarake ei näkyvillä", JOptionPane.ERROR_MESSAGE);
        }
    }

    /**
     * Näyttää taulukossa kaikki huoneet ja niihin liittyvän datan. Asettaa
     * tarvittavat rajoittimet ja sarakevalitsimet pois käytöstä / käyttöön sekä
     * valitsee oletusnäkymässä näkyvillä olevat sarakkeet näytettäviksi
     * piilottaen muut.
     */
    private void switchToRoomData() {
        setEnabled(roomComponents, true);
        setEnabled(peopleComponents, false);
        setSelected(defaultRoomCheckboxes);

        table = roomTable;
        table.setAutoCreateColumnsFromModel(false);
        table.getTableHeader().setReorderingAllowed(false);
        table.setEnabled(false);
        columnModel = table.getColumnModel();
        showColumns(defaultRoomColumns);
        addSorter();
        tableContainer.setViewportView(table);
    }

    /**
     * Näyttää taulukossa kaikki henkilöt ja niihin liittyvän datan. Asettaa
     * tarvittavat rajoittimet ja sarakevalitsimet pois käytöstä / käyttöön sekä
     * valitsee oletusnäkymässä näkyvillä olevat sarakkeet näytettäviksi
     * piilottaen muut.
     */
    private void switchToPeopleData() {
        setEnabled(peopleComponents, true);
        setEnabled(roomComponents, false);
        setSelected(initialComponents);
        
        table = peopleTable;
        columnModel = table.getColumnModel();
        peopleModel.setTable(table);
        table.setAutoCreateColumnsFromModel(false);
        table.getTableHeader().setReorderingAllowed(false);
        table.setEnabled(false);

        addSorter();
        tableContainer.setViewportView(table);
    }

    /**
     * Muuttaaa checkboxien tilan siten, että ne ovat käytössä tai pois käytöstä
     * sen mukaan, mitä se saa parametrina.
     *
     * @param components lista niistä checkboxeista, joiden tila muutetaan
     * @param b true, jos komponentit pitää asettaa käyttöön ja false jos pois
     */
    private void setEnabled(List<JComponent> components, boolean b) {
        for (JComponent comp : components) {
            comp.setEnabled(b);
        }
    }

    /**
     * Luo taulukon joka sisältää kaikki henkilöt ja niihin liittyvän datan.
     *
     */
    private void initPeopleData() {
        peopleTableData = rsession.getPeopleData();
    }

    /**
     * Luo taulukon, joka sisältää kaikki tiedossa olevat huoneet ja niihin
     * liittyvät tiedot.
     */
    private void initRoomData() {
        roomTableData = rsession.getRoomData();
    }
    /**
     * Muuttaa näkymää sen perusteella, pitääkö myös epäaktiiviset henkilöt
     * näyttää vai ei.
     * Käytännössä piirtää uusiksi koko taulukon.
     */
    private void showInactive() {
            initColumnData();
            switchToPeopleData();
            showColumns(initiallyHiddenColumns);
    }
}
